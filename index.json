[{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/aes/","section":"Tags","summary":"","title":"AES","type":"tags"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/block-cipher/","section":"Tags","summary":"","title":"Block Cipher","type":"tags"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/","section":"Home","summary":"","title":"Home","type":"page"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/subset-product/","section":"Tags","summary":"","title":"Subset Product","type":"tags"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/subset-sum/","section":"Tags","summary":"","title":"Subset Sum","type":"tags"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Unsolved Challs from Local CTFs #1 # Recently, two local CTFs were held which I didn\u0026rsquo;t have the chance to participate in, it had some unsolved crypto challs which I decided to solve outside of the CTFs :)\nWreck IT CTF 6.0 # I didn\u0026rsquo;t participate in Wreck IT CTF 6.0 which was open to public, but I \u0026ldquo;participated\u0026rdquo; via discord chat with the crypto legend azuketto. Until the end of the CTF only 1/4 crypto challs had any solve (and of course it had one solve). For this writeup I will be covering 2 challenges on AES CBC which I find to be a fresh breath of air amidst all the number theory stuff, as it had been a while since block cipher challenges appeared in local CTFs.\nPharloom # Technically this challenge is not unsolved as it had 1 solve at the end of the CTF, but I\u0026rsquo;m covering it here since it relates with the next chall.\nSource Code: # chall.py from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from hashlib import md5 import random import os KEY = os.urandom(16) FLAG = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;rb\u0026#39;).read() K = 2 def encrypt(data: bytes, K: int = K): pt = pad(data, 16) iv = md5(pt).digest()[:16] ct = pt for _ in range(K): cipher = AES.new(KEY, AES.MODE_CBC, iv) ct = cipher.encrypt(ct) return iv, ct def decrypt(data: bytes, iv: bytes): pt = data for _ in range(K): cipher = AES.new(KEY, AES.MODE_CBC, iv) pt = cipher.decrypt(pt) pt = unpad(pt, 16) return pt def chall(): global KEY IV, CT = encrypt(FLAG) while True: try: choice = int(input(\u0026#34;\u0026gt;\u0026gt; \u0026#34;)) if choice == 1: Encrypt data = bytes.fromhex(input(\u0026#34;Data (hex): \u0026#34;)) iv, ct = encrypt(data) print(ct.hex()) elif choice == 2: data = bytes.fromhex(input(\u0026#34;Data (hex): \u0026#34;)) iv = bytes.fromhex(input(\u0026#34;IV (hex): \u0026#34;)) pt = decrypt(data, iv) print(ct.hex()) elif choice == 3: Flag print(IV.hex()) print(CT.hex()) elif choice == 4: KEY = os.urandom(16) IV, CT = encrypt(FLAG) print(\u0026#34;Done\u0026#34;) else: print(\u0026#34;Bye\u0026#34;) exit(0) except Exception as e: print(\u0026#34;Nope\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: chall() Problem Statement # The challenge exposes a simple AES-CBC service with two oracles and a flag dump. Everything is encrypted using a single global 16-byte AES key and CBC applied twice (K = 2). The important part is that the IV is not random — it is deterministically computed as:\nIV = md5(pad(pt))[:16] The service offers:\nEncrypt arbitrary data\nYou provide a plaintext data in hex, it is padded, its IV is computed from that padded plaintext, and then the server returns the ciphertext after running two rounds of AES-CBC with the same IV.\nDecrypt arbitrary data\nYou send any ciphertext and any IV you want, and the server decrypts it through the same two CBC layers and finally unpads it.\nGet the flag ciphertext\nThe server prints:\nthe IV used for the flag the ciphertext of FLAG encrypted under the same double-CBC scheme. Reset the key\nRegenerates the AES key and re-encrypts the flag.\nSo the interaction model is: an encrypt oracle with fixed deterministic IV, a decrypt oracle with user-controlled IV, and the flag encrypted once under the global key.\nInitial Thoughts # I noticed there\u0026rsquo;s a clear padding oracle in decrypt, as exceptions are handled by printing 'Nope' without terminating the script. The question now becomes: how do we leverage this padding oracle under this weird encryption scheme?\nSo I scribbled some things to figure out what it\u0026rsquo;s doing and pretty quickly got this! (I cleaned it up a bit):\niv pt1 pt2 pt3 E(pt1 ^ iv) == ct1 | E(ct1 ^ pt2) == ct2 E(ct1 ^ iv) == ctt1 | E(ctt1 ^ ct2) == ctt2 ivf ctt1 ctt2 D(ctt1) ^ ivf = ct1 ^ ivf | D(ctt2) ^ ctt1 = ct2 D(ct1 ^ ivf) ^ ivf | D(ct2) ^ ct1 ^ ivf = pt2 ^ ivf (This is Where the padding oracle is) The scribbling describes itself! Here ivf is the forged IV, and the way to get a padding oracle is that this forged IV will eventually be XORed into the decryption result of the second block — the same way the previous block is XORed in a normal padding oracle attack.\nBut notice: we cannot use the padding oracle to decrypt the first block, because we require another block before the block we want to decrypt. I tried to find some trick because I thought I missed something, but after confirming with the author, the flag prefix is long and the remaining characters are hex. This means out of the 16 characters in the first block, we know:\nWRECKIT60{ and the remaining 6 characters are lowercase hex chars:\n16^6 = 16,777,216 possibilities Which is brute-forceable using the IV and MD5 hash as validator.\nsolve.py from pwn import * from Crypto.Util.Padding import unpad import itertools, hashlib ------------------------- connect + helpers (yours) ------------------------- target = remote(\u0026#34;143.198.215.203\u0026#34;, 8031) def oracle(data, iv): target.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) target.sendlineafter(b\u0026#34;Data (hex): \u0026#34;, data.hex().encode()) target.sendlineafter(b\u0026#34;IV (hex): \u0026#34;, iv.hex().encode()) line = target.recvline() return b\u0026#34;Nope\u0026#34; not in line def get_enc(): target.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) IV = bytes.fromhex(target.recvline().strip().decode()) CT = bytes.fromhex(target.recvline().strip().decode()) return CT, IV def prime_oracle(): do one encrypt so menu 2 prints something on success target.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) target.sendlineafter(b\u0026#34;Data (hex): \u0026#34;, b\u0026#34;00\u0026#34;) ------------------------- K=2 CBC padding attack for P2..Pn (unchanged logic) ------------------------- def chunk16(b): return [b[i:i+16] for i in range(0, len(b), 16)] def recover_block(prev2, prev1, block): payload = prev1 + block plain = bytearray(16) for pad in range(1, 17): i = 16 - pad found = False for g in range(256): iv_try = bytearray(prev2) set already solved suffix to pad for j in range(1, pad): iv_try[-j] ^= plain[-j] ^ pad set guess on current byte iv_try[-pad] ^= g small guard to avoid trivial p==1 hit if pad == 1: iv_try[-2] ^= 1 if oracle(payload, bytes(iv_try)): real plaintext byte = pad ⊕ orig_prev2 ⊕ forged_prev2 plain[-pad] = pad ^ prev2[-pad] ^ iv_try[-pad] found = True break if not found: raise RuntimeError(f\u0026#34;no byte found at pad={pad}\u0026#34;) return bytes(plain) def recover_tail(): prime_oracle() CT, IVF = get_enc() blocks = [IVF] + chunk16(CT) C0=IVF, C1..Cn recovered = b\u0026#34;\u0026#34; while len(blocks) \u0026gt;= 3: prev2, prev1, blk = blocks[-3], blocks[-2], blocks[-1] pblk = recover_block(prev2, prev1, blk) recovered = pblk + recovered print(recovered) blocks.pop() remaining [IVF, C1] — P1 not recoverable via oracle; return tail and IVF return recovered, IVF ------------------------- Brute P1 using md5(P1||tail)[:16] == IVF First block must be: b\u0026#34;WRECKIT60{\u0026#34; + six hex chars (lowercase) ------------------------- def brute_first_block(ivf, tail): prefix = b\u0026#34;WRECKIT60{\u0026#34; assert len(prefix) == 10 alphabet = b\u0026#34;0123456789abcdef\u0026#34; for tup in itertools.product(alphabet, repeat=6): 16^6 = 16,777,216 p1 = prefix + bytes(tup) 10 + 6 = 16 bytes if hashlib.md5(p1 + tail).digest()[:16] == ivf: return p1 return None def main(): tail, ivf = recover_tail() print(f\u0026#34;[+] Recovered tail length: {len(tail)} bytes (P2..Pn).\u0026#34;) p1 = brute_first_block(ivf, tail) if not p1: print(\u0026#34;[-] P1 not found in 16^6 space (unexpected for this flag format).\u0026#34;) print(tail) return full_pt = p1 + tail try: flag = unpad(full_pt, 16).decode(\u0026#39;utf-8\u0026#39;, \u0026#39;replace\u0026#39;) print(f\u0026#34;[+] FLAG: {flag}\u0026#34;) except Exception: print(f\u0026#34;[+] Full plaintext (hex): {(p1+tail).hex()}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Abyss # Source Code: # chall.py from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from hashlib import md5 import random import os KEY = os.urandom(16) FLAG = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;rb\u0026#39;).read() K = 2 ecb_encrypt = lambda x : AES.new(KEY, AES.MODE_ECB).encrypt(x) ecb_decrypt = lambda x : AES.new(KEY, AES.MODE_ECB).decrypt(x) to_blocks = lambda x : [x[i:i+16] for i in range(0, len(x), 16)] def encrypt(data: bytes, iv: bytes = None): pt = pad(data, 16) if iv is None: iv = md5(pt).digest()[:16] ct = pt cipher = AES.new(KEY, AES.MODE_CBC, iv) for _ in range(K): ct = cipher.encrypt(ct) return iv, ct def decrypt(data: bytes, iv: bytes): pt = data cipher = AES.new(KEY, AES.MODE_CBC, iv) for _ in range(K): pt = cipher.decrypt(pt) pt = pt[-16:] return pt def chall(): global KEY IV, CT = encrypt(FLAG) while True: try: choice = int(input(\u0026#34;\u0026gt;\u0026gt; \u0026#34;)) if choice == 1: Encrypt data = bytes.fromhex(input(\u0026#34;Data (hex): \u0026#34;)) iv, ct = encrypt(data) print(ct.hex()) elif choice == 2: data = bytes.fromhex(input(\u0026#34;Data (hex): \u0026#34;)) iv = bytes.fromhex(input(\u0026#34;IV (hex): \u0026#34;)) pt = decrypt(data, iv) print(pt.hex()) elif choice == 3: Flag print(IV.hex()) print(CT.hex()) elif choice == 4: KEY = os.urandom(16) IV, CT = encrypt(FLAG) print(\u0026#34;Done\u0026#34;) else: print(\u0026#34;Bye\u0026#34;) exit(0) except Exception as e: print(\u0026#34;Nope\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: chall() Problem Statement # This challenge exposes another AES-based oracle, again using a single global 16-byte key and CBC applied twice (K = 2), but with two major differences from Pharloom:\nThe cipher\u0026rsquo;s IV isn\u0026rsquo;t reset — meaning the IV for the second CBC pass begins as the last ciphertext block of the first pass. The decryption oracle never unpads; instead, it returns only the final 16-byte block after the two-layer CBC decryption. The encryption oracle lets you optionally override the IV, but when omitted it is once again: IV = md5(pad(pt))[:16] The service gives:\nEncrypt arbitrary data — plaintext is padded, the IV is derived (or user-supplied), and ciphertext is produced via double CBC. Decrypt arbitrary data — returns only the last block after double decryption. Flag ciphertext — prints the flag IV and ciphertext. Reset key — regenerates key + re-encrypts the flag. Unlike Pharloom, there is no padding oracle here — the decrypt path never raises unpad().\nInitial Thoughts # This challenge initially seems a lot tougher as the vulnerability isn\u0026rsquo;t obvious! Actually, there\u0026rsquo;s an obvious vulnerability which LLM could figure out, that is the decryption actually yields the correct final block for number of block size \u0026gt;= 3. I wasted some time on this, but it turns out that this leads nowhere as the first and second blocks are still missing. So instead i turn my head to the encryption service and do some scribbling\nEncrypt x E(md5 ^ x) E(E(md5 ^ x) ^ E(md5 ^ x)) gives encryption of zero Okay, as it turns out when we encrypt only one block, we get encryption of zero! I knew, this would be big and we can leverage it in decrypt as such\niv E(0) D(E(0)) ^ iv = iv D(iv) ^ E(0) (this is what decrypt returns) So, by decrypting the encryption of zero, we get decryption of iv xored with encryption of zero. Since we know what the encryption of zero is, we can then xor it with the output to get the decryption of iv. Since we can choose our iv this effectively becomes an ECB decryption oracle! Then, everything else is easy.\nsolve.py from pwn import * LOCALHOST, PORT = \u0026#34;localhost\u0026#34;, 1337 r = remote(LOCALHOST, PORT) def menu(x) : r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt; \u0026#34;, str(x).encode()) def encrypt(data) : menu(1) r.sendlineafter(b\u0026#34;Data (hex): \u0026#34;, data.hex().encode()) return bytes.fromhex(r.recvline(drop = True).decode()) def decrypt(data, iv) : menu(2) r.sendlineafter(b\u0026#34;Data (hex): \u0026#34;, data.hex().encode()) r.sendlineafter(b\u0026#34;IV (hex): \u0026#34;, iv.hex().encode()) return bytes.fromhex(r.recvline(drop = True).decode()) def get_flag() : menu(3) return bytes.fromhex(r.recvline(drop = True).decode()), bytes.fromhex(r.recvline(drop = True).decode()) iv, ct = get_flag() zero_enc = encrypt(b\u0026#34;\\x00\u0026#34;) def ecb_decrypt(data) : return xor(decrypt(zero_enc, data), zero_enc) def cbc_decrypt_loop(data) : blocks = [data[i:i+16] for i in range(0, len(data), 16)][::-1] result = [] for block, iv in zip(blocks[:-1], blocks[1:]) : result.append(xor(ecb_decrypt(block), iv)) result.append(xor(ecb_decrypt(blocks[-1]), result[0])) return result[::-1] def cbc_decrypt(data, iv) : blocks = [data[i:i+16] for i in range(0, len(data), 16)] result = [] last = iv for block in blocks : result.append(xor(ecb_decrypt(block), last)) last = block return result tmp1 = b\u0026#34;\u0026#34;.join(cbc_decrypt_loop(ct)) tmp2 = cbc_decrypt(tmp1, iv) print(b\u0026#34;\u0026#34;.join(tmp2)) Schematics CTF 2025 # Again, Schematics CTF 2025 is an event which i didn\u0026rsquo;t participate in due to conflict with another CTF, the qualification stage challs weren\u0026rsquo;t that interesting. I dm\u0026rsquo;d the author regarding the final stage challenge to assert dominance learn from them and i found one of them to be quite interesting\nFracture Ray # Source Code # chall.py from Crypto.Util.number import * from Crypto.Random import * from gmpy2 import mpz from sympy import * from hashlib import * import signal, sys with open(\u0026#39;flag.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: flag = f.read().strip() def H(tag, m: bytes) -\u0026gt; bytes: return sha3_256(tag + m).digest()[:8] def sign(N, d, tag, m: bytes) -\u0026gt; int: h = H(tag, m) return pow(mpz(int.from_bytes(h, \u0026#39;big\u0026#39;)), d, N) def verify(N, e, tag, m: bytes, s: int) -\u0026gt; bool: v = pow(s, e, N) vb = long_to_bytes(v) return vb[:8] == H(tag, m) def main(): a = getRandomInteger(2048) b = getRandomInteger(2048) p = nextprime(a) q = nextprime(b) N = p * q e = 0x10001 d = pow(e, -1, (p - 1) * (q - 1)) tag = get_random_bytes(16) print(f\u0026#34;N = {N}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;tag = {tag.hex()}\u0026#34;) msgs = [get_random_bytes(3) for _ in range(96)] for m in msgs: s = sign(N, d, tag, m) print(m.hex(), format(s, \u0026#34;x\u0026#34;)) target = b\u0026#34;https://www.youtube.com/watch?v=1v7WXxLWSrk\u0026#34; signal.alarm(67) try: s_hex = input(\u0026#34;s: \u0026#34;).strip() s = int(s_hex, 16) except Exception: print(\u0026#34;whuh\u0026#34;) sys.exit(0) if verify(N, e, tag, target, s): print(f\u0026#39;yay!!!! here flag: {flag}\u0026#39;) else: print(\u0026#39;nuh uh\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() Problem Statement # This challenge implements a custom RSA signing scheme where messages are first hashed using:\n$$ H(\\text{tag}, m) = \\text{SHA3-256}(\\text{tag} | m)[:8] $$\nand the signature is computed as a plain RSA exponentiation:\n$$ s = H(\\text{tag}, m)^d \\bmod N $$\nThe public verification process exponentiates the signature:\n$$ v = s^e \\bmod N $$\nand checks whether the first 8 bytes of v match the 8-byte digest of the message under the same keyed hash.\nAt the start of the challenge, the server:\nGenerates two random 2048-bit integers a and b, takes their next primes p = nextprime(a) and q = nextprime(b), and uses them to construct a 4096-bit RSA modulus:\n$$ N = p \\cdot q $$\nSamples a random 16-byte tag used for all hashing operations.\nProduces 96 message–signature pairs, where each message is a random 3-byte string and each signature is correct under the unknown private key d.\nYour goal is to forge a valid signature on a specific target message:\nb\u0026#34;https://www.youtube.com/watch?v=1v7WXxLWSrk\u0026#34; You must output a hexadecimal integer s such that:\npow(s, e, N) begins with the 8-byte value:\nH(tag, target) If verification succeeds, the server reveals the flag.\nThe service provides:\nThe RSA modulus N and public exponent e. The secret per-session 16‑byte tag. 96 challenge signatures s_i for random short messages m_i. A single opportunity to submit one forged signature s for the fixed target message. The problem thus reduces to constructing an integer s satisfying:\n$$ s^e \\equiv H(\\text{tag}, \\text{target}) \\pmod{N} $$\nwithout knowledge of the RSA private key.\nInitial Thoughts # There is a clear vulnerability that sticks out! that is why would you only use 8 bytes of the hash equaling to a 64 bits integer for the verification?\nAnother common rsa signature trick is that rsa is a multiplicatively homomorphic scheme, which is a fancy way of saying \\(S(a) * S(b) = S(a * b)\\), where a and b here are the hash of the respective message\nSo the win condition actually becomes rather loose, since the verification is done by decoding the signature, then converting it into bytes and checking only the first 8 bytes, this means it doesn\u0026rsquo;t matter what the decoded signature size is as long as when it is converted to bytes the first 8 bytes is the same as the first 8 bytes of the message hash\nOkay, combined with the fact that we\u0026rsquo;re given 96 signatures from 64 bit integers, there has got to be a way to multiply them such that when converted to bytes they have the 8 bytes prefix that we want! This fact is rather obvious, what is not however is finding such product as subset product is not really an easily solvable problem especially under modulo N.\nHowever, subset product (even under modulo N) can be turned into subset sum via logarithm, this is showcased in an obvious manner by Zyan on the chall LoveLinhaLot on Vietnam ASCIS CTF Final 2024, as well as more recently by Whale120 on chall Republic of Geese in QnQsec ctf 2025.\nThe difference however is that in both of those we\u0026rsquo;re working with discrete logarithm, while in this challenge clearly it\u0026rsquo;s impossible to solve discrete logarithm mod N. However, the trick is that we don\u0026rsquo;t need to do discrete logarithm, as our prefix is only 64 bits, while the modulo is 4096 bits, this means we can set our target to be 4064 bits, and there should be many solutions such that the top 64 bits are the same\nSubset Product → Subset Sum # Before going further, let me clarify the “subset product → subset sum using logarithms” thing a bit more. In any multiplicative group \\(G\\), if you have elements \\(g_i\\) and you want to pick a subset whose product equals some target \\(g\\), the natural way to linearize the problem is to take logarithms:\n\\[ \\log(g) = \\log\\left(\\prod g_i^{c_i}\\right) = \\sum c_i \\cdot \\log(g_i) \\]\nExactly the same structure: subset product becomes subset sum.\nThe only difference is what kind of logarithm you are allowed to take.\nIn finite fields or groups modulo a prime, this “log” is the discrete logarithm. In \\(\\mathbb{R}^+\\), the log is the usual real-valued logarithm. The concept is identical — the logarithm converts multiplication into addition — but discrete logs are usually computationally infeasible, while real logs are trivial.\nIn the previous CTF challenges (LoveLinhaLot and Republic of Geese), the trick worked because the challenge structure let you exploit discrete logs. But here, computing discrete log mod \\(N\\) is impossible.\nThe key observation — and the reason we can still use the trick anyway — is that we don’t need exact equality in the group.\nThe RSA verification only checks the first 8 bytes of the decoded value.\nSo instead of solving:\n\\[ \\prod h_i^{c_i} = H_{\\text{target}} \\pmod{N} \\]\nwe only need:\nthe top 64 bits to match, the remaining ~4064 bits can be anything. This huge slack means we can safely treat the \\(h_i\\) values as regular integers and use real-valued logarithms:\n\\[ \\log(h_i) \\in \\mathbb{R} \\]\nThen solve the approximate subset sum:\n\\[ \\sum c_i \\cdot \\log(h_i) \\approx \\log(H_{\\text{target}} \\ll 4000) \\]\nThe goal is simply to get the magnitude right.\nOnce we find coefficients \\(c_i\\) making the real-valued sum land in the right interval, the actual modular product:\n\\[ \\prod h_i^{c_i} \\bmod N \\]\ntends to fall in the range whose top 64 bits match the needed prefix, because many such integers exist.\nSo, we just have to solve the subset sum problem which can be done via lattice method! Initially, i tried to construct my own lattice and reducing that, but, i end up getting negative coefficients which sadly won\u0026rsquo;t work since those negative coefficients correspond to division in real numbers which is an operation that we can\u0026rsquo;t mirror mod n (at least in terms of keeping the prefix). After trying to configure the lattice for a bit using CVP to get all positive solutions and failing miserably, i decided to ACTUALLY learn the correct way to solve this problem which is by using Integer Linear Programming (ILP). Thankfully, we just use Blupper\u0026rsquo;s implementation and find out it\u0026rsquo;s super easy to use and after a bit of parameter tuning eventually gets a solution that works about 90% of the time and \u0026lt; 10 seconds in local :D\nsolve.py from sage.all import * from pwn import * from hashlib import sha3_256 from Crypto.Util.number import long_to_bytes from time import time from linineq import solve_bounded start = time() def H(tag, m: bytes) -\u0026gt; bytes: return sha3_256(tag + m).digest()[:8] r = remote(\u0026#34;localhost\u0026#34;, 1337) r.recvuntil(b\u0026#34;N = \u0026#34;) N = int(r.recvline()) r.recvuntil(b\u0026#34;e = \u0026#34;) e = int(r.recvline()) r.recvuntil(b\u0026#34;tag = \u0026#34;) tag = bytes.fromhex(r.recvline().decode()) dim = 30 samples = [] for _ in range(dim) : m, s = list(map(lambda x : int(x, 16), r.recvline().strip().decode().split(\u0026#39; \u0026#39;))) samples.append((m, s, pow(s, e, N))) R = RealField(3000) log_s = [R(log_b(h)) for _, _, h in samples[:dim]] sig_target = b\u0026#34;https://www.youtube.com/watch?v=1v7WXxLWSrk\u0026#34; actual_h = H(tag, sig_target) h_target = int.from_bytes(actual_h) \u0026lt;\u0026lt; 4000 log_target = R(log_b(h_target)) scaler = 2**69 L = [ZZ(int(l * scaler)) for l in log_s] L_target = ZZ(int(log_target * scaler)) M = matrix(ZZ, 1, dim+1, L + [1]) b = [L_target] Kmax = 1000 Emax = 100 lb = [0] * dim + [-Emax] ub = [Kmax] * dim + [ Emax] solution = solve_bounded(M, b, lb, ub) coeffs = list(solution[:dim]) eps = solution[-1] print(\u0026#34;coeffs:\u0026#34;, coeffs) print(\u0026#34;eps:\u0026#34;, eps) test = 1 for coeff, (m, s, h) in zip(coeffs, samples) : test = (test * pow(h, coeff, N)) assert long_to_bytes(test)[:8] == actual_h forged = 1 for coeff, (m, s, h) in zip(coeffs, samples) : forged = (forged * pow(s, coeff, N)) % N r.sendlineafter(b\u0026#34;s: \u0026#34;, hex(forged)) end = time() - start print(f\u0026#34;That took {end} s\u0026#34;) r.interactive() After consulting with the author, turns out this is an unintended way of solving which i figured since i only used 30 of the 96 given output to solve it!\nAlthough the author didn\u0026rsquo;t intend for it, it turns out to be a great challenge and made me learn how to do Integer Linear Programming and add it to my toolkit! :D\n","date":"17 November 2025","externalUrl":null,"permalink":"/posts/interesting-unsolved-challs-1/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eUnsolved Challs from Local CTFs #1\n    \u003cdiv id=\"unsolved-challs-from-local-ctfs-1\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#unsolved-challs-from-local-ctfs-1\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003eRecently, two local CTFs were held which I didn\u0026rsquo;t have the chance to participate in, it had some unsolved crypto challs which I decided to solve outside of the CTFs :)\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eWreck IT CTF 6.0\n    \u003cdiv id=\"wreck-it-ctf-60\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#wreck-it-ctf-60\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eI didn\u0026rsquo;t participate in Wreck IT CTF 6.0 which was open to public, but I \u0026ldquo;participated\u0026rdquo; via discord chat with the crypto legend \u003ccode\u003eazuketto\u003c/code\u003e. Until the end of the CTF only 1/4 crypto challs had any solve (and of course it had one solve). For this writeup I will be covering 2 challenges on AES CBC which I find to be a fresh breath of air amidst all the number theory stuff, as it had been a while since block cipher challenges appeared in local CTFs.\u003c/p\u003e","title":"Unsolved Challs from Local CTFs #1","type":"posts"},{"content":"","date":"21 July 2025","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":" l3akctf2025 - Dual MT DRBG # Recently i participated in l3akctf2025, and during the CTF I mainly focused on doing the cryptography challenges. I managed to solve the least-solved challenge in this category, \u0026ldquo;Dual MT DRBG\u0026rdquo;.\nSource Code: # server.py from random import Random from flag import FLAG import os r1 = Random() r1.seed(os.urandom(32)) r2 = Random() r2.seed(os.urandom(32)) print(\u0026#34;Dual Mersenne Twister Deterministic Random Bit Generator\u0026#34;) num_words = int(input(\u0026#34;n=\u0026#34;)) if num_words \u0026gt; 100000: print(\u0026#34;Network bandwidth doesnt grow on trees!\u0026#34;) exit(1) L = [] for i in range(num_words): v1 = r1.getrandbits(32) v2 = r2.getrandbits(32) # break symmetry by rotating v2 L.append((v1 + (v2 ^ ((v2 \u0026gt;\u0026gt; 1) | (v2 \u0026amp; 1) \u0026lt;\u0026lt; 31))) \u0026amp; 0xffffffff) print(\u0026#34;L=\u0026#34;+str(L)) print(\u0026#34;Recover the states of r1 and r2 to get the flag.\u0026#34;) print(\u0026#34;Enter the next 624 outputs of r1:\u0026#34;) for i in range(624): v1 = int(input(\u0026#34;v1=\u0026#34;)) if v1 != r1.getrandbits(32): print(\u0026#34;Incorrect guess\u0026#34;) exit(1) print(\u0026#34;Now enter the next 624 outputs of r2:\u0026#34;) for i in range(624): v2 = int(input(\u0026#34;v2=\u0026#34;)) if v2 != r2.getrandbits(32): print(\u0026#34;Incorrect guess\u0026#34;) exit(1) print(\u0026#34;Congratulations, here is the flag:\u0026#34;, FLAG) The core of the challenge involves two independent instances of Python\u0026rsquo;s Random, which we can refer to as r1 and r2.\nThe server provides us with a sequence of outputs. for each step, it generates an integer a_i from r1 and another integer b_i from r2. These are then combined using the following formula to produce the output o_i that we receive:\n$$ o_i = (a_i + (b_i \\oplus \\text{ROR}(b_i, 1))) \\pmod{2^{32}} $$\nWhere:\na_i is the i-th output of r1. b_i is the i-th output of r2. \\oplus denotes the bitwise XOR operation. \\text{ROR}(b_i, 1) represents a 32-bit circular right shift of b_i by one position. The expression (b_i \u0026gt;\u0026gt; 1) | (b_i \u0026amp; 1) \u0026lt;\u0026lt; 31 in the source code is a common Python implementation of this operation. We can query the server for up to 99,999 of these consecutive o_i values.\nGiven this stream of o_i values, our task is to predict the next 624 outputs from r1 and r2.\nInitial Thoughts # This challenge actually seems rather straightforward to me, since Python\u0026rsquo;s random under the hood uses MT19937, which is a linear PRNG. The challenge becomes how to actually get equations from the output, considering 32-bit integer addition is not linear over GF(2)\nLinear here means linear over the finite field GF(2). For the rest of this write-up, \u0026ldquo;addition\u0026rdquo; refers to the bitwise XOR operation, and \u0026ldquo;multiplication\u0026rdquo; refers to standard integer multiplication, unless stated otherwise.\nThe Linearity of MT19937 # Okay, but before going into the solver, I will first cover these points:\nWhat does \u0026ldquo;linear\u0026rdquo; even mean? How do we know MT19937 is linear? How can we model it using linear algebra? What does \u0026ldquo;linear\u0026rdquo; even mean? # For this write-up, I will be referring to and using the Python MT19937 implementation from this GitHub repository: tliston/mt19937.\nAnd for the rest of this writeup we will be mostly working with the \u0026lsquo;state\u0026rsquo; which refers to the internal 624 * 32 bit state of the MT, not the output of the MT.\nThe concept of linearity is easy enough: a transformation T is linear if T(a + b) = T(a) + T(b) for all a and b. One nice thing about linear transformations is that they can be represented as matrices. Working with matrices is desirable because we can easily add, compose, or inverse them, among many other things. Another key property to note is that a composition of linear transformations is also linear.\nIn the context of a PRNG, when we say it is \u0026ldquo;linear,\u0026rdquo; we mean that its outputs are generated via a linear transformation applied to its internal state.\nHow do we know MT19937 is linear? # Well, we could just test it by generating a random state and verifying if T(a + b) = T(a) + T(b). This can be confirmed with the following Python code:\nfrom mt19937 import mt19937 from tqdm import trange import random correct = True for _ in trange(10000) : s1 = [random.getrandbits(32) for _ in range(624)] s2 = [random.getrandbits(32) for _ in range(624)] s3 = [a ^ b for a, b in zip(s1, s2)] r1, r2, r3 = mt19937(0), mt19937(0), mt19937(0) r1.MT = s1 r2.MT = s2 r3.MT = s3 for i in range(624) : if r1.extract_number() ^ r2.extract_number() != r3.extract_number() : correct = False print(correct) Another way of looking at it is by examining the transformations themselves. In the MT19937 algorithm, there are two core transformations: the twist (for state transition) and the temper (part of extract_number in the example code). Both of these are composed of only XORs and bitwise shift instructions, which are linear operations over GF(2). Since the composition of linear operations is also linear, we can conclude that the entire process is linear.\nHow can we model it using linear algebra? # Now that all that is done, how do we transform the bitwise mess into linear algebra? The way to do that is by first modeling each bitwise transformation as a matrix multiplication over GF(2), and then composing them by multiplying their corresponding matrices.\nThis process is modeled as such in SageMath, using vectors and matrices over GF(2). If you\u0026rsquo;re confused on why the shift matrices is as it is, i advise you to print them out and do the matrix multiplication in your head, it should make sense.\nbitwise_sage.py from sage.all import GF, vector, Matrix, identity_matrix F = GF(2) def int_to_vec(n: int, num_bits: int = None): \u0026#34;\u0026#34;\u0026#34;Convert an integer to a GF(2) vector representation with optional bit width.\u0026#34;\u0026#34;\u0026#34; if num_bits is None: num_bits = n.bit_length() or 1 bits = [(n \u0026gt;\u0026gt; i) \u0026amp; 1 for i in range(num_bits)] return vector(F, bits[::-1]) def vec_to_int(v): \u0026#34;\u0026#34;\u0026#34;Convert a GF(2) vector back to an integer.\u0026#34;\u0026#34;\u0026#34; bits = list(v) return sum(int(b) \u0026lt;\u0026lt; (len(bits) - 1 - i) for i, b in enumerate(bits)) def xor(v1, v2): \u0026#34;\u0026#34;\u0026#34;Bitwise XOR (^) of two GF(2) vectors.\u0026#34;\u0026#34;\u0026#34; return v1 + v2 # In GF(2), addition is the same as XOR def left_shift_matrix(n, shift_amount): \u0026#34;\u0026#34;\u0026#34;Generate the transformation matrix for a bitwise left shift operation by shift_amount.\u0026#34;\u0026#34;\u0026#34; M = Matrix(F, n, n) for i in range(n - shift_amount): M[i, i + shift_amount] = 1 return M def right_shift_matrix(n, shift_amount): \u0026#34;\u0026#34;\u0026#34;Generate the transformation matrix for a bitwise right shift operation by shift_amount with truncation.\u0026#34;\u0026#34;\u0026#34; M = Matrix(F, n, n) for i in range(shift_amount, n): M[i, i - shift_amount] = 1 return M Okay, that\u0026rsquo;s all good for the temper part, but what about the twist? Well, you probably could come up with the matrix by hand, but I\u0026rsquo;m too lazy to do that. Luckily, there\u0026rsquo;s another way to do it using what I like to call the bit contribution concept.\nThe MT19937 internal state consists of 624 32-bit numbers, so we can model the entire state as a single vector of 624 * 32 = 19968 bits. When we multiply a vector by a matrix in GF(2), we can think of the columns of the matrix as the \u0026ldquo;contribution\u0026rdquo; of each input bit to the final output vector. For example, for a matrix M, the element at row 7, column 10 represents the contribution of the 10th input bit to the 7th output bit.\nTo formalize this, let v be the input state vector, M be the linear transformation (twist) matrix, and w be the resulting state vector. The operation is simply w = Mv.\nTo find a specific column of M, say the j-th column, we can feed the transformation function a standard basis vector ej. This is a vector that has only the j-th bit set to 1, and all other bits set to 0. The output of this operation will be the j-th column of the matrix M:\n$$\\text{column}_j(M) = M \\cdot e_j = M \\cdot \\begin{pmatrix} 0 \\ \\vdots \\ 1 \\ \\vdots \\ 0 \\end{pmatrix} \\leftarrow \\text{j-th position}$$\nThe problem we\u0026rsquo;re facing is that we have a function that performs the transformation, but we want to model it as a matrix. We can do exactly what the math above describes: for each bit position, we create a vector with only that single bit active and transform it. The resulting vector is the \u0026ldquo;bit contribution\u0026rdquo; for that position, which gives us one column of the transformation matrix. By repeating this for every possible bit index (from 0 to 19967), we can recover the entire transformation matrix.\nThis is done using this C code:\ntwist.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; // MT19937 Constants #define W 32 #define N 624 #define M 397 #define R 31 #define A 0x9908B0DF #define UPPER_MASK 0x80000000 #define LOWER_MASK 0x7FFFFFFF #define N_BITS (N * W) // 19968 void bitwise_twist(uint32_t mt[]) { for (int i = 0; i \u0026lt; N; ++i) { uint32_t x = (mt[i] \u0026amp; UPPER_MASK) + (mt[(i + 1) % N] \u0026amp; LOWER_MASK); uint32_t xA = x \u0026gt;\u0026gt; 1; if ((x % 2) != 0) { xA ^= A; } mt[i] = mt[(i + M) % N] ^ xA; } } void bitvec_to_numbers(const uint8_t bitvec[], uint32_t numbers[]) { for (int i = 0; i \u0026lt; N; ++i) { numbers[i] = 0; for (int k = 0; k \u0026lt; W; ++k) { if (bitvec[i * W + k]) { numbers[i] |= (1UL \u0026lt;\u0026lt; (W - 1 - k)); } } } } void numbers_to_bitvec(const uint32_t numbers[], uint8_t bitvec[]) { for (int i = 0; i \u0026lt; N; ++i) { for (int k = 0; k \u0026lt; W; ++k) { bitvec[i * W + k] = (numbers[i] \u0026gt;\u0026gt; (W - 1 - k)) \u0026amp; 1; } } } int main() { printf(\u0026#34;Starting empirical recovery of the %dx%d MT19937 twist matrix in C.\\n\u0026#34;, N_BITS, N_BITS); printf(\u0026#34;This will be significantly faster than Python...\\n\u0026#34;); size_t packed_row_size = N_BITS / 8; size_t matrix_size = N_BITS * packed_row_size; uint8_t *T = (uint8_t *)malloc(matrix_size); if (T == NULL) { perror(\u0026#34;Failed to allocate memory for matrix T\u0026#34;); return 1; } memset(T, 0, matrix_size); uint8_t *current_col = (uint8_t *)malloc(N_BITS); if (current_col == NULL) { perror(\u0026#34;Failed to allocate memory for column vector\u0026#34;); free(T); return 1; } uint32_t temp_mt_state[N]; // --- Main Recovery Loop --- for (int j = 0; j \u0026lt; N_BITS; ++j) { memset(current_col, 0, N_BITS); current_col[j] = 1; bitvec_to_numbers(current_col, temp_mt_state); bitwise_twist(temp_mt_state); numbers_to_bitvec(temp_mt_state, current_col); // `current_col` now holds the output vector // Place this output column into the j-th column of the packed matrix T. for (int i = 0; i \u0026lt; N_BITS; ++i) { if (current_col[i] == 1) { // Calculate the position in the packed array for T[i][j] size_t byte_index = (size_t)i * packed_row_size + (j / 8); uint8_t bit_mask = (1 \u0026lt;\u0026lt; (j % 8)); T[byte_index] |= bit_mask; } } if ((j + 1) % 500 == 0) { double progress = (double)(j + 1) / N_BITS * 100.0; printf(\u0026#34;Progress: %d / %d columns recovered (%.2f%%)\\n\u0026#34;, j + 1, N_BITS, progress); } } printf(\u0026#34;Matrix recovery complete. Saving to \u0026#39;matrix.txt\u0026#39;...\\n\u0026#34;); // --- Save Matrix to File --- FILE *fp = fopen(\u0026#34;matrix.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp == NULL) { perror(\u0026#34;Failed to open output file\u0026#34;); free(T); free(current_col); return 1; } for (int i = 0; i \u0026lt; N_BITS; ++i) { for (int j = 0; j \u0026lt; N_BITS; ++j) { size_t byte_index = (size_t)i * packed_row_size + (j / 8); uint8_t bit_mask = (1 \u0026lt;\u0026lt; (j % 8)); fputc((T[byte_index] \u0026amp; bit_mask) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;, fp); } fputc(\u0026#39;\\n\u0026#39;, fp); } fclose(fp); free(T); free(current_col); printf(\u0026#34;Done. The matrix has been saved to \u0026#39;matrix.txt\u0026#39;.\\n\u0026#34;); return 0; } Finally, with the matrices for both the temper and twist operations recovered, we can create our own MT19937 implementation that works entirely through matrix multiplication.\nMatrix Mulitiplication MT19937 from bitwise_sage import * from tqdm import tqdm, trange N_BITS = 19968 T = Matrix(F, N_BITS, N_BITS, sparse=True) with open(\u0026#39;../matrix.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: for i, line in enumerate(tqdm(f, total=N_BITS, desc=\u0026#34;Processing Rows\u0026#34;, unit=\u0026#34; rows\u0026#34;)): for j, char in enumerate(line): if char == \u0026#39;1\u0026#39;: T[i, j] = 1 BIT_SIZE = 32 class symbolic_mt19937(): u, d = 11, 0xFFFFFFFF s, b = 7, 0x9D2C5680 t, c = 15, 0xEFC60000 l = 18 n = 624 * BIT_SIZE def my_int32(self, x): return(x \u0026amp; 0xFFFFFFFF) def __init__(self, state): r = BIT_SIZE - 1 self.m = 397 self.a = 0x9908B0DF self.index = self.n + 1 self.lower_mask = (1 \u0026lt;\u0026lt; r) - 1 self.upper_mask = self.my_int32(~self.lower_mask) self.lower_mask = int_to_vec(self.lower_mask, BIT_SIZE) self.upper_mask = int_to_vec(self.upper_mask, BIT_SIZE) self.MT = state self.temper_matrix = None self.untemper_matrix = None self.xa_matrix = None self.is_matrix = hasattr(state, \u0026#34;ncols\u0026#34;) def get_temper_matrix(self) : if self.temper_matrix != None : return self.temper_matrix mat = xor(bitwise_identity_matrix(BIT_SIZE), and_transformation_matrix(int_to_vec(self.d, BIT_SIZE)) * right_shift_matrix(BIT_SIZE, self.u)) mat = xor(bitwise_identity_matrix(BIT_SIZE), and_transformation_matrix(int_to_vec(self.b, BIT_SIZE)) * left_shift_matrix(BIT_SIZE, self.s)) * mat mat = xor(bitwise_identity_matrix(BIT_SIZE), and_transformation_matrix(int_to_vec(self.c, BIT_SIZE)) * left_shift_matrix(BIT_SIZE, self.t)) * mat mat = xor(bitwise_identity_matrix(BIT_SIZE), right_shift_matrix(BIT_SIZE, self.l)) * mat self.temper_matrix = mat return mat def get_untemper_matrix(self) : if self.untemper_matrix != None : return self.untemper_matrix else : self.untemper_matrix = self.get_temper_matrix().inverse() return self.get_untemper_matrix() def temper(self, V) : return self.get_temper_matrix() * V def untemper(self, V) : return self.get_untemper_matrix() * V def extract_number(self): if self.index \u0026gt;= self.n: self.twist() self.index = 0 y = vector(GF(2), self.MT[self.index : self.index + 32]) self.index += 32 return vec_to_int(self.get_temper_matrix() * y) def twist(self): self.MT = T * self.MT def twist_long(self) : for i in range(0, 624): bit_index = i * 32 mdexed = (bit_index + self.m * BIT_SIZE) % self.n bitdex = (bit_index + 33) % self.n if self.is_matrix : x = self.MT.matrix_from_columns([bit_index]).augment(self.MT.matrix_from_columns(list(range(bitdex, bitdex + 31)))) xA = self.xA_matrix() * x.T xA = xA.T self.MT[:, bit_index:bit_index+32] = self.MT[:, mdexed : mdexed + 32] + xA else : x = self.MT[bit_index:bit_index+1].concatenate(self.MT[bitdex : bitdex + 31]) xA = self.xA_matrix() * x self.MT[bit_index:bit_index + 32] = self.MT[mdexed : mdexed + 32] + xA if self.is_matrix : self.MT = self.MT.T def xA_matrix(self) : if self.xa_matrix : return self.xa_matrix else : transformation_matrix = Matrix(F, 32, 32) for i in range(32) : x = 1 \u0026lt;\u0026lt; (31 - i) xA = x \u0026gt;\u0026gt; 1 if(x \u0026amp; 1) == 1: xA = xA ^ self.a transformation_matrix[:, i] = int_to_vec(xA, 32) self.xa_matrix = transformation_matrix return self.xA_matrix() def numbers_to_bitvec(numbers) : res = [] for num in numbers : res.extend(list(int_to_vec(num, 32))) return vector(F, res) Awesome! Now all that\u0026rsquo;s left is to deal with the tangled output equation:\n$$o_i = (a_i + (b_i \\oplus \\text{ROR}(b_i, 1))) \\pmod{2^{32}}$$\nLet\u0026rsquo;s simplify the inner term by defining b'_i = b_i ⊕ ROR(b_i, 1). As we\u0026rsquo;ve established, this b'_i term is a linear transformation of b_i and can be represented by a matrix. The equation becomes o_i = (a_i + b'_i) mod 2^32. The real problem is the standard integer addition (+).\nThe problem with integer addition essentially is that the value of o_i at the k-th bit isn\u0026rsquo;t just determined by the k-th bit of a_i and b'_i, rather it is also determined by the carry from the preceding bit. However, if there is no carry bit, then the operation is essentially just XOR. This condition of no carry bit clearly applies for the LSB (Least Significant Bit), meaning we can absolutely construct an equation using the output\u0026rsquo;s LSB. However, for reasons I\u0026rsquo;m not 100% sure of either, getting a leak from a single position like this doesn\u0026rsquo;t actually allow you to recover the whole state rather during testing, it only recovered about half of the bits.\nNow, what I came up with is that if the LSB of the output is 1, then we know the carry bit is 0. Because the carry bit is 0, this means that the 2nd LSB is essentially just XOR of the 2nd LSB of a_i and b'_i as well. Then, if the output\u0026rsquo;s 2nd bit is also 1, we know for sure that the carry will also be 0. This chain of logic goes on up to the MSB.\nBasically, consecutive set bits from the LSB guarantee that the bits at those positions are the XORs of the a_i and b'_i bits. This allows us to recover on average 2 bits per output, and since the positions will be somewhat diverse, it does allow us to recover the state completely.\nState Recovery # For the state recovery itself, I did it by initializing the symbolic MT with an identity matrix. Essentially, this allows us to represent a bit from the MT output as a linear equation in terms of variables bit0 to bit19967 of the initial state. So in the solver, the columns of our large matrix represent each initial state bit, and the rows represent a linear combination of those bits that equals a known output bit. In other words: row[i] • initial_state = MT_output_bit[i]. This gives us a system of linear equations in variables bit_0 to bit_19967 for both the MT1 and MT2 states.\nNow, one thing I haven\u0026rsquo;t mentioned is that there are 31 bits from the initial state that are essentially \u0026ldquo;discarded\u0026rdquo; and not used to generate the next state. This is why it\u0026rsquo;s called MT19937 (since 19968 - 31 = 19937). These 31 discarded bits just so happen to be used only in the tempering of the very first 32-bit output. This means the only way we could recover these specific bits is from the very first output of the PRNG, but this is impossible since we can only infer a few bits from that single output.\nThis, however, poses no problem since our goal is to predict future outputs, not recover the exact initial state. As long as we can recover the 19937 bits that are propagated to the next state, we can predict all future outputs. In total, this requires our system of equations to produce a matrix with a rank of (19937 * 2) to solve for both PRNGs.\nWell, there is one problem though: 19968 x 19968 matrix multiplication is kinda slow. My symbolic twist function takes around 3.5 minutes to run once. Given that we recover about 2 bits per output, it would require around 20,000 outputs, which means we\u0026rsquo;d have to perform the twist operation about 32 times. The total time for twisting alone would be around 108 minutes.\nDuring the competition, I ran with it anyway because 108 minutes really isn\u0026rsquo;t that long. I was worried that maybe the server had some sort of timeout or rate limit, but whatever i just ran the script, prayed for no timeout and got the flag :)\nsolve.py from sage.all import * from pwn import * from bitwise_sage import F, xor, right_rot_matrix from random import getrandbits from symbolicmt import symbolic_mt19937 from tqdm import trange, tqdm # # Testing Code # s1 = symbolic_mt19937.numbers_to_bitvec([getrandbits(32) for _ in range(624)]) # s2 = symbolic_mt19937.numbers_to_bitvec([getrandbits(32) for _ in range(624)]) # r1 = symbolic_mt19937(s1.__copy__()) # r2 = symbolic_mt19937(s2.__copy__()) # r1.index = 0 # r2.index = 0 # c1 = [] # c2 = [] # c3 = [] # L = [] # for i in trange(90000): # v1 = r1.extract_number() # v2 = r2.extract_number() # # break symmetry by rotating v2 # L.append((v1 + (v2 ^ ((v2 \u0026gt;\u0026gt; 1) | (v2 \u0026amp; 1) \u0026lt;\u0026lt; 31))) \u0026amp; 0xffffffff) # c1.append(v1) # c2.append(v2) # c3.append(((v2 ^ ((v2 \u0026gt;\u0026gt; 1) | (v2 \u0026amp; 1) \u0026lt;\u0026lt; 31))) \u0026amp; 0xffffffff) target = remote(\u0026#34;34.59.96.214\u0026#34;, 11002) target.sendlineafter(b\u0026#34;n=\u0026#34;, b\u0026#34;25000\u0026#34;) target.recvuntil(b\u0026#34;L=\u0026#34;) L = eval(target.recvline().strip().decode()) smt1 = symbolic_mt19937(identity_matrix(F, 19968)) eqmat = matrix(F, [0 for _ in range(19968 * 2)]) result = [0] twist_count = 0 # val1 = [] # val2 = [] # val3 = [0] rottemp = right_rot_matrix(32, 1) * smt1.get_temper_matrix() for i, c in tqdm(list(enumerate(L))) : if i % 624 == 0 and i \u0026gt; 0 : print(f\u0026#34;Twisting for the {twist_count + 1} time\u0026#34;) smt1.twist() twist_count += 1 base_part = smt1.MT.submatrix(i * 32 - twist_count * 19968, 0, 32, 19968) current_part1 = smt1.get_temper_matrix() * base_part current_part2 = xor(smt1.get_temper_matrix() * base_part, rottemp * base_part) # val1.append(vec_to_int(current_part1 * s1)) # val2.append(vec_to_int(current_part2 * s2)) # val3.append(vector(list(current_part1[31]) + list(current_part2[31])).dot_product(vector(list(s1) + list(s2)))) bits = list(map(int, bin(c)[2:].zfill(32))) for bit_pos in range(31, -1, -1) : eqmat = eqmat.stack(vector(list(current_part1[bit_pos]) + list(current_part2[bit_pos]))) result.append(bits[bit_pos]) if bits[bit_pos] == 0 : break if i % 1000 == 0 : print(eqmat.rank()) if eqmat.rank() \u0026gt;= (19937) * 2 : break eqech = eqmat.augment(vector(F, result)).echelon_form() print(\u0026#34;\\n--- Analyzing the Echelon Form ---\u0026#34;) solution_part = eqech.column(-1) eq_part = eqech.matrix_from_columns(range(eqech.ncols() - 1)) matrank = eq_part.rank() num_vars = eq_part.ncols() bits_missing = num_vars - matrank print(f\u0026#34;System Rank: {matrank}\u0026#34;) print(f\u0026#34;Total Variables: {num_vars}\u0026#34;) print(f\u0026#34;Undetermined Bits (Degrees of Freedom): {bits_missing}\u0026#34;) pivots = eq_part.pivots() non_pivots = sorted(list(set(range(num_vars)) - set(pivots))) # We assume the free variables (non-pivots) are all 0 s_recovered_partial = vector(F, num_vars) for i in trange(matrank - 1, -1, -1): pivot_col = pivots[i] val = solution_part[i] s_recovered_partial[pivot_col] = val print(\u0026#34;\\n--- Verifying the Recovered State ---\u0026#34;) # Split the combined solution vector back into two separate state vectors s1_recovered = s_recovered_partial[:19968] s2_recovered = s_recovered_partial[19968:] # Create new MT instances from the recovered states r1_recovered = symbolic_mt19937(s1_recovered) r2_recovered = symbolic_mt19937(s2_recovered) r1_recovered.index = 0 r2_recovered.index = 0 print(\u0026#34;\\nGenerating outputs from the recovered state...\u0026#34;) recovered_outputs1 = [] recovered_outputs2 = [] test_outputs = [] for _ in range(624): r1_recovered.extract_number() r2_recovered.extract_number() for _ in trange(25000-624, desc=\u0026#34;Generating from recovered state\u0026#34;): v1 = r1_recovered.extract_number() v2 = r2_recovered.extract_number() recovered_outputs1.append(v1) recovered_outputs2.append(v2) test_outputs.append((v1 + (v2 ^ ((v2 \u0026gt;\u0026gt; 1) | (v2 \u0026amp; 1) \u0026lt;\u0026lt; 31))) \u0026amp; 0xffffffff) if test_outputs == L[624:]: print(\u0026#34;\\nSUCCESS!\u0026#34;) else: print(f\u0026#34;\\nFAILURE\u0026#34;) for i in range(624) : target.sendlineafter(b\u0026#34;v1=\u0026#34;, str(r1_recovered.extract_number()).encode()) for i in range(624) : target.sendlineafter(b\u0026#34;v2=\u0026#34;, str(r2_recovered.extract_number()).encode()) target.interactive() ","date":"21 July 2025","externalUrl":null,"permalink":"/posts/l3akctf2025-dual-mt-drbg/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003el3akctf2025 - Dual MT DRBG\n    \u003cdiv id=\"l3akctf2025---dual-mt-drbg\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#l3akctf2025---dual-mt-drbg\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003eRecently i participated in l3akctf2025, and during the CTF I mainly focused on doing the cryptography challenges. I managed to solve the least-solved challenge in this category, \u0026ldquo;Dual MT DRBG\u0026rdquo;.\u003c/p\u003e\n\u003chr\u003e\n\n\u003ch2 class=\"relative group\"\u003eSource Code:\n    \u003cdiv id=\"source-code\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#source-code\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\n\u003cdetails\u003e\n  \u003csummary\u003eserver.py\u003c/summary\u003e\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003erandom\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eRandom\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003eflag\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eos\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003er1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eRandom\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003er1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eseed\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eurandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003er2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eRandom\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003er2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eseed\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eurandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Dual Mersenne Twister Deterministic Random Bit Generator\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enum_words\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003einput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;n=\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003enum_words\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e100000\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Network bandwidth doesnt grow on trees!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eL\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum_words\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ev1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetrandbits\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetrandbits\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# break symmetry by rotating v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eL\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003ev1\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e31\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xffffffff\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;L=\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"nb\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eL\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Recover the states of r1 and r2 to get the flag.\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Enter the next 624 outputs of r1:\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e624\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ev1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003einput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;v1=\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ev1\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetrandbits\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Incorrect guess\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Now enter the next 624 outputs of r2:\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e624\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003einput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;v2=\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ev2\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003er2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetrandbits\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Incorrect guess\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Congratulations, here is the flag:\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/details\u003e\n\n\u003cp\u003eThe core of the challenge involves two independent instances of Python\u0026rsquo;s \u003ccode\u003eRandom\u003c/code\u003e, which we can refer to as \u003ccode\u003er1\u003c/code\u003e and \u003ccode\u003er2\u003c/code\u003e.\u003c/p\u003e","title":"l3akctf2025 — Dual MT DRBG","type":"posts"},{"content":"","date":"21 July 2025","externalUrl":null,"permalink":"/tags/linear-algebra/","section":"Tags","summary":"","title":"Linear Algebra","type":"tags"},{"content":"","date":"21 July 2025","externalUrl":null,"permalink":"/tags/mt19937/","section":"Tags","summary":"","title":"MT19937","type":"tags"},{"content":"Dedicated CTF Player from Indonesia, actively participating in national and international CTFs mainly doing cryptography and reverse engineering challenges.\nYou can check out writeups of ctf challenges and some of my study notes here.\nFeel free to contact me through discord!\n","externalUrl":null,"permalink":"/about/","section":"Home","summary":"\u003cp\u003eDedicated CTF Player from Indonesia, actively participating in national and international CTFs mainly doing cryptography and reverse engineering challenges.\u003c/p\u003e\n\u003cp\u003eYou can check out writeups of ctf challenges and some of my study notes here.\u003c/p\u003e\n\u003cp\u003eFeel free to contact me through discord!\u003c/p\u003e","title":"About","type":"page"}]